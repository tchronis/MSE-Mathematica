(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Echo["Loaded maximize.m"];


(* ::Input::Initialization:: *)
maxIterations=Automatic;
seedrandom=0;


(* ::Input::Initialization:: *)
ClearAll[optimize];
optimize::method="I cannot recognize an optimization method named \"`1`\".";
optimize["methods"]={"Automatic",{"DifferentialEvolution","CrossProbability"->0.5,"InitialPoints"->Automatic,"PenaltyFunction"->Automatic,"PostProcess"->Automatic,"RandomSeed"->randomSeed,"ScalingFactor"->0.6,"SearchPoints"->Automatic,"Tolerance"->0.001},"NelderMead","SimulatedAnnealing","RandomSearch",{"ParticleSwarmOptimization","nparts"->32,"bndLo"->-10,"bndUp"->10,"niter"->100,"r"->1,"RandomSeed"->randomSeed}};
optimize::usage="optimize[f,x,method] is a wrapper that involves several separated optimization methods. f must be defined as a pure function in the sense f=func[Sequence@@#]&. x is a list of uknowns {x1,x2,...,xn}. Implemented methods for now include Mathematica's DifferentialEvolution, SimulatedAnnealing, RandomSearch, NelderMead. ParticleSwarmOptimization is an external method (PSO).\r

Each method carries its own parameters. Default parameters can be changed as in the following examples:

example1:
optimize[\"parameters\"] = { {\"ParticleSwarmOptimization\", 32, 0, 10, 100, 8}};

example2:
method -> {\"DifferentialEvolution\", \"CrossProbability\" -> 0.5,  \"ScalingFactor\" -> 0.6, \"RandomSeed\" -> 0, \"SearchPoints\" -> 200}";
optimize[f_,x_,method_:"DifferentialEvolution"]:=Module[{f1,sol,m},

objectivecounter=0; (*Initialize calls to 0*)

m=If[StringQ@method,method,method[[1]]];

(*Print[method];*)

Switch[m,
"Automatic",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"DifferentialEvolution",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"SimulatedAnnealing",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"RandomSearch",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],
"NelderMead",
	sol=NMaximize[f[x],x,MaxIterations->maxIterations,Method->method,StepMonitor:> Sow[x]],

"ParticleSwarmOptimization",
f1=Function[{x1},-f[x1]];
sol=If[StringQ@method,
PSO[f1,x],
PSO[f1,x,Sequence@@(method[[2;;All]])]
];
sol[[1]]=-sol[[1]];sol[[2]]=Thread[x->sol[[2]]],

_,Message[optimize::method,method];sol=0];

sol
];
(*Information[optimize,LongForm\[Rule]False]*)


(* ::Input::Initialization:: *)
ClearAll[maximize];
maximize::usage="maximize[dataArray_,noAttr_,method_:\"DifferentialEvolution\", permuteinvariant_:True, printflag_:True] is MSE specific and uses the optimize function. It uses the objective function (that counts the number of satisfied inequalities). It returns a list {max,{x1->value1, x2->value2, ...}, number of inequalities} where max is the maximum number of satisfied inequalities found and the solution of the maximization method {value1,value2,...}";
maximize[dataArray_,noAttr_,method_:"DifferentialEvolution",permuteinvariant_:True,printflag_:True]:=Module[{sol,x,
order,invariantdataArray,reverseorder},

If[!(Developer`PackedArrayQ[dataArray]),Print["WARNING - The dataArray IS NOT a packed array. Calculations will be severely slowed down."]];

x=Cx[noAttr-1];

If[permuteinvariant,
order=Ordering[(*Smaller deviation first*)
N[StandardDeviation/@(Transpose@dataArray[[All,2;;-1]])]
];
invariantdataArray=dataArray[[All,Prepend[order+1,1]]];(*invariantdataArray remains packed*)

sol=optimize[objective[invariantdataArray,Sequence@@#]&,x,method];

sol={sol[[1]],x/.sol[[2]]};

reverseorder=SortBy[Transpose[{sol[[2]],order}],Last][[All,1]];

sol={sol[[1]],reverseorder,Length@dataArray};

If[printflag,Print[" The new ordering of attributes used for calculating the solutio order=",order(*,"  reverse order=",reverseorder*)]]
,

sol=optimize[objective[dataArray,Sequence@@#]&,x,method];

sol={sol[[1]],x/.sol[[2]],Length@dataArray}
];

If[printflag,
Print["Method "<>ToString[method]];
Print["Completed : ",
{"Number of satisfied inequalities"->sol[[1]],Thread[header[[5;;(5+noAttr-2)]]->sol[[2]]],"Number of inequalities"->Length@dataArray},
"\nSatisfied Ineqs Analysis:\n ",
Grid[objectiveV[dataArray,Sequence@@(sol[[2]])],Frame->All]
]
];
sol
];
Information[maximize,LongForm->False]
